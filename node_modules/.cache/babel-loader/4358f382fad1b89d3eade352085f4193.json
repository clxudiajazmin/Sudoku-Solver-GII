{"ast":null,"code":"import { EventEmitter } from \"events\"; //Extracción de modelo y sudoku solver\n\nimport fillInPrediction from \"../ReconocimientoImagen/Loadmodel\";\nimport SudokuSolver from \"../Solver/sudokusolver\"; //Funciones procesamiento de imagen\n\nimport getLargestConnectedComponent, { getRegionEntrePuntos } from \"../ProcesamientoImagen/RegionEntrePuntos\";\nimport getCornerPoints from \"../ProcesamientoImagen/Esquinas\";\nimport findHomographicTransform, { transformPoint, extractSquareFromRegion } from \"../ProcesamientoImagen/Homographic\";\nimport Image from \"../ProcesamientoImagen/Imagen\";\nimport boxBlur from \"../ProcesamientoImagen/Blur\"; // Mínimo de celdas del sudoku\n\nconst MIN_BOXES = 17; // tamaño de la imagen a procesar\n\nconst PROCESSING_SIZE = 900;\nexport default class Processor extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.video = void 0;\n    this.isVideoRunning = false;\n    this.isProcessing = false;\n    this.corners = void 0;\n    this.gridLines = void 0;\n    this.solvedPuzzle = void 0;\n    this.TiempoTotal = 0;\n  }\n\n  /**\n   * Empieza a usar la cámara\n   */\n  async startVideo(video) {\n    this.isProcessing = true;\n    this.video = video; //Solo video no audio\n\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: \"environment\",\n        width: 640\n      },\n      audio: false\n    }); // Obtener las dimensiones del video capturado\n\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight\n      });\n    };\n\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n    var playPromise = this.video.play();\n\n    if (playPromise !== undefined && this.isProcessing === true) {\n      playPromise.then(_ => {\n        console.log(\"Video funcionando\");\n        this.isVideoRunning = true;\n        this.processFrame();\n      }).catch(error => {\n        console.log(\"Video no funciona\");\n      });\n    }\n  }\n\n  captureImagen(video) {\n    const canvas = document.createElement(\"canvas\");\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\"); // Dibujamos el video capturado por la cámara al canvas\n\n    context.drawImage(video, 0, 0, width, height); // Obtenemos los bytes\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const bytes = new Uint8ClampedArray(width * height); // Convertimos a blanco y negro\n\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n\n      for (let x = 0; x < width; x++) {\n        const r = imageData.data[(y * width + x) * 4];\n        const g = imageData.data[(row + x) * 4 + 1];\n        const b = imageData.data[(y * width + x) * 4 + 2];\n        const grey = 0.299 * r + 0.587 * g + 0.114 * b;\n        bytes[row + x] = grey;\n      }\n    }\n\n    return new Image(bytes, width, height);\n  }\n  /**\n   * THRESHOLD\n   */\n\n\n  threshold(imagen, threshold, blurSize) {\n    const {\n      width,\n      height,\n      bytes\n    } = imagen;\n    const blurred = boxBlur(imagen, blurSize, blurSize);\n    const blurredBytes = blurred.bytes;\n\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n\n      for (let x = 0; x < width; x++) {\n        bytes[row + width + x] = blurredBytes[row + x] - bytes[row + width + x] > threshold ? 255 : 0;\n      }\n    }\n\n    return imagen;\n  }\n  /**\n   * Crear los grids\n   */\n\n\n  createGridLines(transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n\n    for (let l = 1; l < 9; l++) {\n      // LINEA HORIZONTAL\n      gridLines.push({\n        p1: transformPoint({\n          x: 0,\n          y: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          x: PROCESSING_SIZE,\n          y: l * boxSize\n        }, transform)\n      }); // LINEA VERTICAL\n\n      gridLines.push({\n        p1: transformPoint({\n          y: 0,\n          x: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          y: PROCESSING_SIZE,\n          x: l * boxSize\n        }, transform)\n      });\n    }\n\n    return gridLines;\n  }\n\n  extractBoxes(greyScale, thresholded) {\n    const results = [];\n    const size = greyScale.width;\n    const boxSize = size / 9;\n    const searchSize = boxSize / 5; //Recorrer cada celda\n\n    for (let y = 0; y < 9; y++) {\n      for (let x = 0; x < 9; x++) {\n        let minX = Number.MAX_SAFE_INTEGER;\n        let minY = Number.MAX_SAFE_INTEGER;\n        let maxX = 0;\n        let maxY = 0;\n        let pointsCount = 0;\n        const searchX1 = x * boxSize + searchSize;\n        const searchY1 = y * boxSize + searchSize;\n        const searchX2 = x * boxSize + boxSize - searchSize;\n        const searchY2 = y * boxSize + boxSize - searchSize;\n\n        for (let searchY = searchY1; searchY < searchY2; searchY++) {\n          for (let searchX = searchX1; searchX < searchX2; searchX++) {\n            if (thresholded.bytes[searchY * size + searchX] === 255) {\n              const component = getRegionEntrePuntos(thresholded, searchX, searchY);\n              const foundWidth = component.limites.bottomRight.x - component.limites.topLeft.x;\n              const foundHeight = component.limites.bottomRight.y - component.limites.topLeft.y;\n\n              if (component.puntos.length > 10 && foundWidth < boxSize && foundHeight < boxSize) {\n                minX = Math.min(minX, component.limites.topLeft.x);\n                minY = Math.min(minY, component.limites.topLeft.y);\n                maxX = Math.max(maxX, component.limites.bottomRight.x);\n                maxY = Math.max(maxY, component.limites.bottomRight.y);\n                pointsCount += component.puntos.length;\n              }\n            }\n          }\n        }\n\n        const foundWidth = maxX - minX;\n        const foundHeight = maxY - minY;\n\n        if (pointsCount > 10 && foundWidth < boxSize && foundHeight < boxSize && foundWidth > boxSize / 10 && foundHeight > boxSize / 3) {\n          const numberImage = greyScale.subImage(Math.max(0, minX - 2), Math.max(0, minY - 2), Math.min(size - 1, maxX + 2), Math.min(size - 1, maxY + 2));\n          results.push({\n            x,\n            y,\n            minX,\n            maxX,\n            minY,\n            maxY,\n            numberImage,\n            contents: 0\n          });\n        }\n      }\n    }\n\n    return results;\n  }\n  /**\n   * Celdas en el video\n   */\n\n\n  getTextDetailsForBox(x, y, digit, isKnown, transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const p1 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: y * boxSize\n    }, transform);\n    const p2 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 1) * boxSize\n    }, transform); // Centro\n\n    const textPosition = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 0.5) * boxSize\n    }, transform); // Angulo de texto\n\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy); // Altura de texto aprox.\n\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      conocido: isKnown,\n      position: textPosition\n    };\n  }\n\n  createSolvedPuzzle(solver, transform) {\n    const results = new Array(9);\n\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n\n    solver.solution.forEach(sol => {\n      const {\n        x,\n        y,\n        entry,\n        isKnown\n      } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(x, y, entry, isKnown, transform);\n    });\n    return results;\n  }\n\n  sanityCheckCorners(_ref) {\n    let {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = _ref;\n\n    function length(p1, p2) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (topLineLength < 0.5 * bottomLineLength || topLineLength > 1.5 * bottomLineLength) return false;\n    if (leftLineLength < 0.7 * rightLineLength || leftLineLength > 1.3 * rightLineLength) return false;\n    if (leftLineLength < 0.5 * bottomLineLength || leftLineLength > 1.5 * bottomLineLength) return false;\n    return true;\n  } //Empieza procesado de video\n\n\n  async processFrame() {\n    this.isProcessing = true;\n\n    try {\n      let startTime = performance.now(); // capturar imagen\n\n      const image = this.captureImagen(this.video); // Aplicar threshold\n\n      const thresholded = this.threshold(image.clone(), 20, 20); // Extraer la región más grande entre los puntos\n\n      const largestConnectedComponent = getLargestConnectedComponent(thresholded, {\n        minAspectRatio: 0.5,\n        maxAspectRatio: 1.5,\n        minSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n        maxSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9\n      }); // Si se encuentra\n\n      if (largestConnectedComponent) {\n        // Calcular esquinas (Manhattan)\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n\n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n          const transform = findHomographicTransform(PROCESSING_SIZE, this.corners); // Mostrar gridlines\n\n          this.gridLines = this.createGridLines(transform); // Extraer tablero grayscale\n\n          const extractedImageGreyScale = extractSquareFromRegion(image, PROCESSING_SIZE, transform); // Extraer tablero de imagen threshold\n\n          const extractedImageThresholded = extractSquareFromRegion(thresholded, PROCESSING_SIZE, transform); // Extraer celdas con números\n\n          const boxes = this.extractBoxes(extractedImageGreyScale, extractedImageThresholded); // Se cumple la condición de mínimos?\n\n          if (boxes.length > MIN_BOXES) {\n            // Aplicar la red neuronal\n            await fillInPrediction(boxes); // Dancing Links\n\n            const solver = new SudokuSolver();\n            boxes.forEach(box => {\n              //console.log(\"El dígito reconocido\", box.contents);\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            }); // Crear solución\n\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n            } else {\n              this.solvedPuzzle = null;\n            }\n\n            this.TiempoTotal = 0.1 * (performance.now() - startTime) + this.TiempoTotal * 0.9;\n            console.log(\"Tiempo de resolución\", this.TiempoTotal);\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    this.isProcessing = false;\n    setTimeout(() => this.processFrame(), 20);\n  }\n\n}","map":{"version":3,"sources":["/Users/claudiasoria/Downloads/Sudoku-Solver-GII/Sudoku-Solver-GII/src/components/Procesador/Processor.ts"],"names":["EventEmitter","fillInPrediction","SudokuSolver","getLargestConnectedComponent","getRegionEntrePuntos","getCornerPoints","findHomographicTransform","transformPoint","extractSquareFromRegion","Image","boxBlur","MIN_BOXES","PROCESSING_SIZE","Processor","video","isVideoRunning","isProcessing","corners","gridLines","solvedPuzzle","TiempoTotal","startVideo","stream","navigator","mediaDevices","getUserMedia","facingMode","width","audio","canPlayListener","removeEventListener","emit","videoWidth","height","videoHeight","addEventListener","srcObject","playPromise","play","undefined","then","_","console","log","processFrame","catch","error","captureImagen","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","bytes","Uint8ClampedArray","y","row","x","r","data","g","b","grey","threshold","imagen","blurSize","blurred","blurredBytes","createGridLines","transform","boxSize","l","push","p1","p2","extractBoxes","greyScale","thresholded","results","size","searchSize","minX","Number","MAX_SAFE_INTEGER","minY","maxX","maxY","pointsCount","searchX1","searchY1","searchX2","searchY2","searchY","searchX","component","foundWidth","limites","bottomRight","topLeft","foundHeight","puntos","length","Math","min","max","numberImage","subImage","contents","getTextDetailsForBox","digit","isKnown","textPosition","dx","dy","digitRotation","atan2","digitHeight","sqrt","conocido","position","createSolvedPuzzle","solver","Array","solution","forEach","sol","entry","guess","sanityCheckCorners","topRight","bottomLeft","topLineLength","leftLineLength","rightLineLength","bottomLineLength","startTime","performance","now","image","clone","largestConnectedComponent","minAspectRatio","maxAspectRatio","minSize","maxSize","potentialCorners","extractedImageGreyScale","extractedImageThresholded","boxes","box","setNumber","search","setTimeout"],"mappings":"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","sourcesContent":["import StrictEventEmitter from \"strict-event-emitter-types\";\nimport { EventEmitter } from \"events\";\n//Extracción de modelo y sudoku solver\nimport fillInPrediction from \"../ReconocimientoImagen/Loadmodel\";\nimport SudokuSolver from \"../Solver/sudokusolver\";\n//Funciones procesamiento de imagen\nimport getLargestConnectedComponent, {\n  getRegionEntrePuntos,\n  Punto,\n} from \"../ProcesamientoImagen/RegionEntrePuntos\";\nimport getCornerPoints from \"../ProcesamientoImagen/Esquinas\";\nimport findHomographicTransform, {transformPoint, extractSquareFromRegion, Transform} from \"../ProcesamientoImagen/Homographic\";\nimport Image from \"../ProcesamientoImagen/Imagen\";\nimport boxBlur from \"../ProcesamientoImagen/Blur\";\n\n// Mínimo de celdas del sudoku\nconst MIN_BOXES = 17;\n// tamaño de la imagen a procesar\nconst PROCESSING_SIZE = 900;\n\nexport type VideoReadyPayload = { width: number; height: number };\n\ninterface ProcessorEvents {\n  videoReady: VideoReadyPayload;\n}\n\ntype ProcessorEventEmitter = StrictEventEmitter<EventEmitter, ProcessorEvents>;\nexport interface PuzzleBox {\n  x: number;\n  y: number;\n  minX: number;\n  maxX: number;\n  minY: number;\n  maxY: number;\n  numberImage: Image;\n  contents: number;\n}\n\ntype SolvedBox = {\n  // El número es conocido o no?\n  conocido: boolean;\n  // El digito \n  digit: number;\n  // Altura de digito\n  digitHeight: number;\n  // Rotación de dígito\n  digitRotation: number;\n  // Posición para dibujar\n  position: Punto;\n};\n\n\n\nexport default class Processor extends (EventEmitter as {\n  new (): ProcessorEventEmitter;\n}) {\n  video: HTMLVideoElement;\n  // El video está corriendo?\n  isVideoRunning: boolean = false;\n  // Se está procesando?\n  isProcessing: boolean = false;\n  // Definición de las esquinas\n  corners: {\n    topLeft: Punto;\n    topRight: Punto;\n    bottomLeft: Punto;\n    bottomRight: Punto;\n  };\n  // Punto para calculo de area\n  gridLines: { p1: Punto; p2: Punto }[];\n  // Sudoku resuelto\n  solvedPuzzle: SolvedBox[][];\n  TiempoTotal: number = 0;\n\n  /**\n   * Empieza a usar la cámara\n   */\n  async startVideo(video: HTMLVideoElement) {\n    this.isProcessing = true;\n    this.video = video;\n    //Solo video no audio\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { facingMode: \"environment\", width: 640 },\n      audio: false,\n    });\n    // Obtener las dimensiones del video capturado\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight,\n      });\n    };\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n\n    var playPromise = this.video.play();\n    if (playPromise !== undefined && this.isProcessing === true) {\n      playPromise.then(_ => {\n        console.log(\"Video funcionando\");\n        this.isVideoRunning = true;\n        this.processFrame();\n      })\n      .catch(error => {\n        console.log(\"Video no funciona\");\n      });\n    }\n  }\n\n  captureImagen(video: HTMLVideoElement) {\n    const canvas = document.createElement(\"canvas\");\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    // Dibujamos el video capturado por la cámara al canvas\n    context!.drawImage(video, 0, 0, width, height);\n    // Obtenemos los bytes\n    const imageData = context!.getImageData(0, 0, width, height);\n    const bytes = new Uint8ClampedArray(width * height);\n    // Convertimos a blanco y negro\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n      for (let x = 0; x < width; x++) {\n        const r = imageData.data[(y * width + x) * 4];\n        const g = imageData.data[(row + x) * 4 + 1];\n        const b = imageData.data[(y * width + x) * 4 + 2];\n        const grey = 0.299 * r + 0.587 * g + 0.114 * b;\n        bytes[row + x] = grey;\n      }\n    }\n    return new Image(bytes, width, height);\n  }\n\n\n  /**\n   * THRESHOLD\n   */\n  threshold(\n    imagen: Image,\n    threshold: number,\n    blurSize: number\n  ): Image {\n    const { width, height, bytes } = imagen;\n    const blurred = boxBlur(imagen, blurSize, blurSize);\n    const blurredBytes = blurred.bytes;\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n      for (let x = 0; x < width; x++) {\n        bytes[row + width + x] =\n          blurredBytes[row + x] - bytes[row + width + x] > threshold ? 255 : 0;\n      }\n    }\n    return imagen;\n  }\n\n\n\n  /**\n   * Crear los grids\n   */\n  createGridLines(transform: Transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n    for (let l = 1; l < 9; l++) {\n      // LINEA HORIZONTAL\n      gridLines.push({\n        p1: transformPoint({ x: 0, y: l * boxSize }, transform),\n        p2: transformPoint({ x: PROCESSING_SIZE, y: l * boxSize }, transform),\n      });\n      // LINEA VERTICAL\n      gridLines.push({\n        p1: transformPoint({ y: 0, x: l * boxSize }, transform),\n        p2: transformPoint({ y: PROCESSING_SIZE, x: l * boxSize }, transform),\n      });\n    }\n    return gridLines;\n  }\n\n\n   extractBoxes(greyScale: Image, thresholded: Image) {\n    const results: PuzzleBox[] = [];\n    const size = greyScale.width;\n    const boxSize = size / 9;\n    const searchSize = boxSize / 5;\n    //Recorrer cada celda\n    for (let y = 0; y < 9; y++) {\n      for (let x = 0; x < 9; x++) {\n        let minX = Number.MAX_SAFE_INTEGER;\n        let minY = Number.MAX_SAFE_INTEGER;\n        let maxX = 0;\n        let maxY = 0;\n        let pointsCount = 0;\n        const searchX1 = x * boxSize + searchSize;\n        const searchY1 = y * boxSize + searchSize;\n        const searchX2 = x * boxSize + boxSize - searchSize;\n        const searchY2 = y * boxSize + boxSize - searchSize;\n        for (let searchY = searchY1; searchY < searchY2; searchY++) {\n          for (let searchX = searchX1; searchX < searchX2; searchX++) {\n            if (thresholded.bytes[searchY * size + searchX] === 255) {\n              const component = getRegionEntrePuntos(\n                thresholded,\n                searchX,\n                searchY\n              );\n              const foundWidth =\n                component.limites.bottomRight.x - component.limites.topLeft.x;\n              const foundHeight =\n                component.limites.bottomRight.y - component.limites.topLeft.y;\n              if (\n                component.puntos.length > 10 &&\n                foundWidth < boxSize &&\n                foundHeight < boxSize\n              ) {\n                minX = Math.min(minX, component.limites.topLeft.x);\n                minY = Math.min(minY, component.limites.topLeft.y);\n                maxX = Math.max(maxX, component.limites.bottomRight.x);\n                maxY = Math.max(maxY, component.limites.bottomRight.y);\n                pointsCount += component.puntos.length;\n              }\n            }\n          }\n        }\n\n        const foundWidth = maxX - minX;\n        const foundHeight = maxY - minY;\n        if (\n          pointsCount > 10 &&\n          foundWidth < boxSize &&\n          foundHeight < boxSize &&\n          foundWidth > boxSize / 10 &&\n          foundHeight > boxSize / 3\n        ) {\n          const numberImage = greyScale.subImage(\n            Math.max(0, minX - 2),\n            Math.max(0, minY - 2),\n            Math.min(size - 1, maxX + 2),\n            Math.min(size - 1, maxY + 2)\n          );\n          results.push({\n            x,\n            y,\n            minX,\n            maxX,\n            minY,\n            maxY,\n            numberImage,\n            contents: 0,\n          });\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Celdas en el video\n   */\n  getTextDetailsForBox(\n    x: number,\n    y: number,\n    digit: number,\n    isKnown: boolean,\n    transform: Transform\n  ): SolvedBox {\n    const boxSize = PROCESSING_SIZE / 9;\n    const p1 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: y * boxSize },\n      transform\n    );\n    const p2 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 1) * boxSize },\n      transform\n    );\n    // Centro\n    const textPosition = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 0.5) * boxSize },\n      transform\n    );\n    // Angulo de texto\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy);\n    // Altura de texto aprox.\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      conocido: isKnown,\n      position: textPosition,\n    };\n  }\n\n  createSolvedPuzzle(solver: SudokuSolver, transform: Transform) {\n    const results: SolvedBox[][] = new Array(9);\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n    solver.solution.forEach((sol) => {\n      const { x, y, entry, isKnown } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(\n        x,\n        y,\n        entry,\n        isKnown,\n        transform\n      );\n    });\n    return results;\n  }\n\n  sanityCheckCorners({\n    topLeft,\n    topRight,\n    bottomLeft,\n    bottomRight,\n  }: {\n    topLeft: Punto;\n    topRight: Punto;\n    bottomLeft: Punto;\n    bottomRight: Punto;\n  }) {\n    function length(p1: Punto, p2: Punto) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (\n      topLineLength < 0.5 * bottomLineLength ||\n      topLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.7 * rightLineLength ||\n      leftLineLength > 1.3 * rightLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.5 * bottomLineLength ||\n      leftLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    return true;\n  }\n  \n  //Empieza procesado de video\n  async processFrame() {\n    this.isProcessing = true;\n    try {\n      let startTime = performance.now();\n      // capturar imagen\n      const image = this.captureImagen(this.video);\n\n      // Aplicar threshold\n      const thresholded = this.threshold(image.clone(), 20, 20);\n      // Extraer la región más grande entre los puntos\n      const largestConnectedComponent = getLargestConnectedComponent(\n        thresholded,\n        {\n          minAspectRatio: 0.5,\n          maxAspectRatio: 1.5,\n          minSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n          maxSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9,\n        }\n      );\n      // Si se encuentra\n      if (largestConnectedComponent) {\n        // Calcular esquinas (Manhattan)\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n        \n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n          const transform = findHomographicTransform(\n            PROCESSING_SIZE,\n            this.corners\n          );\n\n          // Mostrar gridlines\n          this.gridLines = this.createGridLines(transform);\n\n          // Extraer tablero grayscale\n          const extractedImageGreyScale = extractSquareFromRegion(\n            image,\n            PROCESSING_SIZE,\n            transform\n          );\n          // Extraer tablero de imagen threshold\n          const extractedImageThresholded = extractSquareFromRegion(\n            thresholded,\n            PROCESSING_SIZE,\n            transform\n          );\n          // Extraer celdas con números\n          const boxes = this.extractBoxes(\n            extractedImageGreyScale,\n            extractedImageThresholded\n          );\n          // Se cumple la condición de mínimos?\n          if (boxes.length > MIN_BOXES) {\n            // Aplicar la red neuronal\n            await fillInPrediction(boxes);\n            // Dancing Links\n            const solver = new SudokuSolver();\n            boxes.forEach((box) => {\n              //console.log(\"El dígito reconocido\", box.contents);\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            });\n            // Crear solución\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n              \n              \n            } else {\n              this.solvedPuzzle = null;\n            }\n            this.TiempoTotal =\n            0.1 * (performance.now() - startTime) + this.TiempoTotal * 0.9;\n            console.log(\"Tiempo de resolución\", this.TiempoTotal)\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n    \n    this.isProcessing = false;\n    setTimeout(() => this.processFrame(), 20);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}