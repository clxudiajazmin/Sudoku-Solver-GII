{"ast":null,"code":"import { EventEmitter } from \"events\"; //Extracción de modelo y sudoku solver\n\nimport fillInPrediction from \"../ReconocimientoImagen/Loadmodel\";\nimport SudokuSolver from \"../Solver/sudokusolver\"; //Funciones procesamiento de imagen\n\nimport getLargestConnectedComponent, { getRegionEntrePuntos } from \"../ProcesamientoImagen/RegionEntrePuntos\";\nimport getCornerPoints from \"../ProcesamientoImagen/Esquinas\";\nimport findHomographicTransform, { transformPoint, extractSquareFromRegion } from \"../ProcesamientoImagen/Homographic\";\nimport Image from \"../ProcesamientoImagen/Imagen\";\nimport boxBlur from \"../ProcesamientoImagen/Blur\"; // Mínimo de celdas del sudoku\n\nconst MIN_BOXES = 17; // tamaño de la imagen a procesar\n\nconst PROCESSING_SIZE = 900;\nexport default class Processor extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.video = void 0;\n    this.isVideoRunning = false;\n    this.isProcessing = false;\n    this.corners = void 0;\n    this.gridLines = void 0;\n    this.solvedPuzzle = void 0;\n    this.TiempoTotal = 0;\n  }\n\n  /**\r\n   * Empieza a usar la cámara\r\n   */\n  async startVideo(video) {\n    this.video = video; //Solo video no audio\n\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: \"environment\",\n        width: 640\n      },\n      audio: false\n    }); // Obtener las dimensiones del video capturado\n\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight\n      }); //Definimos la variable a true -> Se está ejecutando la cámara\n\n      this.isVideoRunning = true; // Empieza el procesamiento\n\n      this.isProcessing = true;\n      this.processFrame();\n    };\n\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n    this.video.play();\n  }\n\n  captureImagen(video) {\n    const canvas = document.createElement(\"canvas\");\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\"); // Dibujamos el video capturado por la cámara al canvas\n\n    context.drawImage(video, 0, 0, width, height); // Obtenemos los bytes\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const bytes = new Uint8ClampedArray(width * height); // Convertimos a blanco y negro\n\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n\n      for (let x = 0; x < width; x++) {\n        const r = imageData.data[(y * width + x) * 4];\n        const g = imageData.data[(row + x) * 4 + 1];\n        const b = imageData.data[(y * width + x) * 4 + 2];\n        const grey = 0.299 * r + 0.587 * g + 0.114 * b;\n        bytes[row + x] = grey;\n      }\n    }\n\n    return new Image(bytes, width, height);\n  }\n  /**\r\n   * THRESHOLD\r\n   */\n\n\n  threshold(imagen, threshold, blurSize) {\n    const {\n      width,\n      height,\n      bytes\n    } = imagen;\n    const blurred = boxBlur(imagen, blurSize, blurSize);\n    const blurredBytes = blurred.bytes;\n\n    for (let y = 0; y < height; y++) {\n      const row = y * width;\n\n      for (let x = 0; x < width; x++) {\n        bytes[row + width + x] = blurredBytes[row + x] - bytes[row + width + x] > threshold ? 255 : 0;\n      }\n    }\n\n    console.log(\"La imagen: \", imagen);\n    return imagen;\n  }\n  /**\r\n   * Crear los grids\r\n   */\n\n\n  createGridLines(transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n\n    for (let l = 1; l < 9; l++) {\n      // LINEA HORIZONTAL\n      gridLines.push({\n        p1: transformPoint({\n          x: 0,\n          y: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          x: PROCESSING_SIZE,\n          y: l * boxSize\n        }, transform)\n      }); // LINEA VERTICAL\n\n      gridLines.push({\n        p1: transformPoint({\n          y: 0,\n          x: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          y: PROCESSING_SIZE,\n          x: l * boxSize\n        }, transform)\n      });\n    }\n\n    return gridLines;\n  }\n\n  extractBoxes(greyScale, thresholded) {\n    const results = [];\n    const size = greyScale.width;\n    const boxSize = size / 9;\n    const searchSize = boxSize / 5; //Recorrer cada celda\n\n    for (let y = 0; y < 9; y++) {\n      for (let x = 0; x < 9; x++) {\n        let minX = Number.MAX_SAFE_INTEGER;\n        let minY = Number.MAX_SAFE_INTEGER;\n        let maxX = 0;\n        let maxY = 0;\n        let pointsCount = 0;\n        const searchX1 = x * boxSize + searchSize;\n        const searchY1 = y * boxSize + searchSize;\n        const searchX2 = x * boxSize + boxSize - searchSize;\n        const searchY2 = y * boxSize + boxSize - searchSize;\n\n        for (let searchY = searchY1; searchY < searchY2; searchY++) {\n          for (let searchX = searchX1; searchX < searchX2; searchX++) {\n            if (thresholded.bytes[searchY * size + searchX] === 255) {\n              const component = getRegionEntrePuntos(thresholded, searchX, searchY);\n              const foundWidth = component.limites.bottomRight.x - component.limites.topLeft.x;\n              const foundHeight = component.limites.bottomRight.y - component.limites.topLeft.y;\n\n              if (component.puntos.length > 10 && foundWidth < boxSize && foundHeight < boxSize) {\n                minX = Math.min(minX, component.limites.topLeft.x);\n                minY = Math.min(minY, component.limites.topLeft.y);\n                maxX = Math.max(maxX, component.limites.bottomRight.x);\n                maxY = Math.max(maxY, component.limites.bottomRight.y);\n                pointsCount += component.puntos.length;\n              }\n            }\n          }\n        }\n\n        const foundWidth = maxX - minX;\n        const foundHeight = maxY - minY;\n\n        if (pointsCount > 10 && foundWidth < boxSize && foundHeight < boxSize && foundWidth > boxSize / 10 && foundHeight > boxSize / 3) {\n          const numberImage = greyScale.subImage(Math.max(0, minX - 2), Math.max(0, minY - 2), Math.min(size - 1, maxX + 2), Math.min(size - 1, maxY + 2));\n          results.push({\n            x,\n            y,\n            minX,\n            maxX,\n            minY,\n            maxY,\n            numberImage,\n            contents: 0\n          });\n        }\n      }\n    }\n\n    return results;\n  }\n  /**\r\n   * Celdas en el video\r\n   */\n\n\n  getTextDetailsForBox(x, y, digit, isKnown, transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const p1 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: y * boxSize\n    }, transform);\n    const p2 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 1) * boxSize\n    }, transform); // Centro\n\n    const textPosition = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 0.5) * boxSize\n    }, transform); // Angulo de texto\n\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy); // Altura de texto aprox.\n\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n    console.log(digit, digitHeight, digitRotation, isKnown, textPosition);\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      conocido: isKnown,\n      position: textPosition\n    };\n  }\n\n  createSolvedPuzzle(solver, transform) {\n    const results = new Array(9);\n\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n\n    solver.solution.forEach(sol => {\n      const {\n        x,\n        y,\n        entry,\n        isKnown\n      } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(x, y, entry, isKnown, transform);\n    });\n    return results;\n  }\n\n  sanityCheckCorners(_ref) {\n    let {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = _ref;\n\n    function length(p1, p2) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (topLineLength < 0.5 * bottomLineLength || topLineLength > 1.5 * bottomLineLength) return false;\n    if (leftLineLength < 0.7 * rightLineLength || leftLineLength > 1.3 * rightLineLength) return false;\n    if (leftLineLength < 0.5 * bottomLineLength || leftLineLength > 1.5 * bottomLineLength) return false;\n    return true;\n  } //Empieza procesado de video\n\n\n  async processFrame() {\n    if (!this.isVideoRunning) {\n      // No hay video \n      return;\n    }\n\n    if (this.isProcessing) {\n      // Se está procesando\n      return;\n    }\n\n    try {\n      let startTime = performance.now(); // capturar imagen\n\n      const image = this.captureImagen(this.video); // Aplicar threshold\n\n      const thresholded = this.threshold(image.clone(), 20, 20); // Extraer la región más grande entre los puntos\n\n      const largestConnectedComponent = getLargestConnectedComponent(thresholded, {\n        minAspectRatio: 0.5,\n        maxAspectRatio: 1.5,\n        minSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n        maxSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9\n      }); // Si se encuentra\n\n      if (largestConnectedComponent) {\n        // Calcular esquinas (Manhattan)\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n\n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n          const transform = findHomographicTransform(PROCESSING_SIZE, this.corners); // Mostrar gridlines\n\n          this.gridLines = this.createGridLines(transform); // Extraer tablero grayscale\n\n          const extractedImageGreyScale = extractSquareFromRegion(image, PROCESSING_SIZE, transform); // Extraer tablero de imagen threshold\n\n          const extractedImageThresholded = extractSquareFromRegion(thresholded, PROCESSING_SIZE, transform); // Extraer celdas con números\n\n          const boxes = this.extractBoxes(extractedImageGreyScale, extractedImageThresholded); // Se cumple la condición de mínimos?\n\n          if (boxes.length > MIN_BOXES) {\n            // Aplicar la red neuronal\n            await fillInPrediction(boxes); // Dancing Links\n\n            const solver = new SudokuSolver();\n            boxes.forEach(box => {\n              console.log(\"El dígito\", box.contents);\n\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            }); // Crear solución\n\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n            } else {\n              this.solvedPuzzle = null;\n            }\n\n            this.TiempoTotal = 0.1 * (performance.now() - startTime) + this.TiempoTotal * 0.9;\n            console.log(\"Tiempo de resolución\", this.TiempoTotal);\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    this.isProcessing = false;\n    setTimeout(() => this.processFrame(), 20);\n  }\n\n}","map":{"version":3,"sources":["D:/GITHUB/Sudoku-Solver-GII/src/components/Procesador/Processor.ts"],"names":["EventEmitter","fillInPrediction","SudokuSolver","getLargestConnectedComponent","getRegionEntrePuntos","getCornerPoints","findHomographicTransform","transformPoint","extractSquareFromRegion","Image","boxBlur","MIN_BOXES","PROCESSING_SIZE","Processor","video","isVideoRunning","isProcessing","corners","gridLines","solvedPuzzle","TiempoTotal","startVideo","stream","navigator","mediaDevices","getUserMedia","facingMode","width","audio","canPlayListener","removeEventListener","emit","videoWidth","height","videoHeight","processFrame","addEventListener","srcObject","play","captureImagen","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","bytes","Uint8ClampedArray","y","row","x","r","data","g","b","grey","threshold","imagen","blurSize","blurred","blurredBytes","console","log","createGridLines","transform","boxSize","l","push","p1","p2","extractBoxes","greyScale","thresholded","results","size","searchSize","minX","Number","MAX_SAFE_INTEGER","minY","maxX","maxY","pointsCount","searchX1","searchY1","searchX2","searchY2","searchY","searchX","component","foundWidth","limites","bottomRight","topLeft","foundHeight","puntos","length","Math","min","max","numberImage","subImage","contents","getTextDetailsForBox","digit","isKnown","textPosition","dx","dy","digitRotation","atan2","digitHeight","sqrt","conocido","position","createSolvedPuzzle","solver","Array","solution","forEach","sol","entry","guess","sanityCheckCorners","topRight","bottomLeft","topLineLength","leftLineLength","rightLineLength","bottomLineLength","startTime","performance","now","image","clone","largestConnectedComponent","minAspectRatio","maxAspectRatio","minSize","maxSize","potentialCorners","extractedImageGreyScale","extractedImageThresholded","boxes","box","setNumber","search","error","setTimeout"],"mappings":"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","sourcesContent":["import StrictEventEmitter from \"strict-event-emitter-types\";\r\nimport { EventEmitter } from \"events\";\r\n//Extracción de modelo y sudoku solver\r\nimport fillInPrediction from \"../ReconocimientoImagen/Loadmodel\";\r\nimport SudokuSolver from \"../Solver/sudokusolver\";\r\n//Funciones procesamiento de imagen\r\nimport getLargestConnectedComponent, {\r\n  getRegionEntrePuntos,\r\n  Punto,\r\n} from \"../ProcesamientoImagen/RegionEntrePuntos\";\r\nimport getCornerPoints from \"../ProcesamientoImagen/Esquinas\";\r\nimport findHomographicTransform, {transformPoint, extractSquareFromRegion, Transform} from \"../ProcesamientoImagen/Homographic\";\r\nimport Image from \"../ProcesamientoImagen/Imagen\";\r\nimport boxBlur from \"../ProcesamientoImagen/Blur\";\r\n\r\n// Mínimo de celdas del sudoku\r\nconst MIN_BOXES = 17;\r\n// tamaño de la imagen a procesar\r\nconst PROCESSING_SIZE = 900;\r\n\r\nexport type VideoReadyPayload = { width: number; height: number };\r\n\r\ninterface ProcessorEvents {\r\n  videoReady: VideoReadyPayload;\r\n}\r\n\r\ntype ProcessorEventEmitter = StrictEventEmitter<EventEmitter, ProcessorEvents>;\r\nexport interface PuzzleBox {\r\n  x: number;\r\n  y: number;\r\n  minX: number;\r\n  maxX: number;\r\n  minY: number;\r\n  maxY: number;\r\n  numberImage: Image;\r\n  contents: number;\r\n}\r\n\r\ntype SolvedBox = {\r\n  // El número es conocido o no?\r\n  conocido: boolean;\r\n  // El digito \r\n  digit: number;\r\n  // Altura de digito\r\n  digitHeight: number;\r\n  // Rotación de dígito\r\n  digitRotation: number;\r\n  // Posición para dibujar\r\n  position: Punto;\r\n};\r\n\r\n\r\n\r\nexport default class Processor extends (EventEmitter as {\r\n  new (): ProcessorEventEmitter;\r\n}) {\r\n  video: HTMLVideoElement;\r\n  // El video está corriendo?\r\n  isVideoRunning: boolean = false;\r\n  // Se está procesando?\r\n  isProcessing: boolean = false;\r\n  // Definición de las esquinas\r\n  corners: {\r\n    topLeft: Punto;\r\n    topRight: Punto;\r\n    bottomLeft: Punto;\r\n    bottomRight: Punto;\r\n  };\r\n  // Punto para calculo de area\r\n  gridLines: { p1: Punto; p2: Punto }[];\r\n  // Sudoku resuelto\r\n  solvedPuzzle: SolvedBox[][];\r\n  TiempoTotal: number = 0;\r\n\r\n  /**\r\n   * Empieza a usar la cámara\r\n   */\r\n  async startVideo(video: HTMLVideoElement) {\r\n    this.video = video;\r\n    //Solo video no audio\r\n    const stream = await navigator.mediaDevices.getUserMedia({\r\n      video: { facingMode: \"environment\", width: 640 },\r\n      audio: false,\r\n    });\r\n    // Obtener las dimensiones del video capturado\r\n    const canPlayListener = () => {\r\n      this.video.removeEventListener(\"canplay\", canPlayListener);\r\n      this.emit(\"videoReady\", {\r\n        width: this.video.videoWidth,\r\n        height: this.video.videoHeight,\r\n      });\r\n      //Definimos la variable a true -> Se está ejecutando la cámara\r\n      this.isVideoRunning = true;\r\n      // Empieza el procesamiento\r\n      this.isProcessing = true;\r\n      this.processFrame();\r\n    };\r\n    this.video.addEventListener(\"canplay\", canPlayListener);\r\n    this.video.srcObject = stream;\r\n    this.video.play();\r\n  }\r\n\r\n  captureImagen(video: HTMLVideoElement) {\r\n    const canvas = document.createElement(\"canvas\");\r\n    const width = video.videoWidth;\r\n    const height = video.videoHeight;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    const context = canvas.getContext(\"2d\");\r\n    // Dibujamos el video capturado por la cámara al canvas\r\n    context!.drawImage(video, 0, 0, width, height);\r\n    // Obtenemos los bytes\r\n    const imageData = context!.getImageData(0, 0, width, height);\r\n    const bytes = new Uint8ClampedArray(width * height);\r\n    // Convertimos a blanco y negro\r\n    for (let y = 0; y < height; y++) {\r\n      const row = y * width;\r\n      for (let x = 0; x < width; x++) {\r\n        const r = imageData.data[(y * width + x) * 4];\r\n        const g = imageData.data[(row + x) * 4 + 1];\r\n        const b = imageData.data[(y * width + x) * 4 + 2];\r\n        const grey = 0.299 * r + 0.587 * g + 0.114 * b;\r\n        bytes[row + x] = grey;\r\n      }\r\n    }\r\n    return new Image(bytes, width, height);\r\n  }\r\n\r\n\r\n  /**\r\n   * THRESHOLD\r\n   */\r\n  threshold(\r\n    imagen: Image,\r\n    threshold: number,\r\n    blurSize: number\r\n  ): Image {\r\n    const { width, height, bytes } = imagen;\r\n    const blurred = boxBlur(imagen, blurSize, blurSize);\r\n    const blurredBytes = blurred.bytes;\r\n    for (let y = 0; y < height; y++) {\r\n      const row = y * width;\r\n      for (let x = 0; x < width; x++) {\r\n        bytes[row + width + x] =\r\n          blurredBytes[row + x] - bytes[row + width + x] > threshold ? 255 : 0;\r\n      }\r\n    }\r\n    console.log(\"La imagen: \", imagen);\r\n    return imagen;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Crear los grids\r\n   */\r\n  createGridLines(transform: Transform) {\r\n    const boxSize = PROCESSING_SIZE / 9;\r\n    const gridLines = [];\r\n    for (let l = 1; l < 9; l++) {\r\n      // LINEA HORIZONTAL\r\n      gridLines.push({\r\n        p1: transformPoint({ x: 0, y: l * boxSize }, transform),\r\n        p2: transformPoint({ x: PROCESSING_SIZE, y: l * boxSize }, transform),\r\n      });\r\n      // LINEA VERTICAL\r\n      gridLines.push({\r\n        p1: transformPoint({ y: 0, x: l * boxSize }, transform),\r\n        p2: transformPoint({ y: PROCESSING_SIZE, x: l * boxSize }, transform),\r\n      });\r\n    }\r\n    return gridLines;\r\n  }\r\n\r\n\r\n   extractBoxes(greyScale: Image, thresholded: Image) {\r\n    const results: PuzzleBox[] = [];\r\n    const size = greyScale.width;\r\n    const boxSize = size / 9;\r\n    const searchSize = boxSize / 5;\r\n    //Recorrer cada celda\r\n    for (let y = 0; y < 9; y++) {\r\n      for (let x = 0; x < 9; x++) {\r\n        let minX = Number.MAX_SAFE_INTEGER;\r\n        let minY = Number.MAX_SAFE_INTEGER;\r\n        let maxX = 0;\r\n        let maxY = 0;\r\n        let pointsCount = 0;\r\n        const searchX1 = x * boxSize + searchSize;\r\n        const searchY1 = y * boxSize + searchSize;\r\n        const searchX2 = x * boxSize + boxSize - searchSize;\r\n        const searchY2 = y * boxSize + boxSize - searchSize;\r\n        for (let searchY = searchY1; searchY < searchY2; searchY++) {\r\n          for (let searchX = searchX1; searchX < searchX2; searchX++) {\r\n            if (thresholded.bytes[searchY * size + searchX] === 255) {\r\n              const component = getRegionEntrePuntos(\r\n                thresholded,\r\n                searchX,\r\n                searchY\r\n              );\r\n              const foundWidth =\r\n                component.limites.bottomRight.x - component.limites.topLeft.x;\r\n              const foundHeight =\r\n                component.limites.bottomRight.y - component.limites.topLeft.y;\r\n              if (\r\n                component.puntos.length > 10 &&\r\n                foundWidth < boxSize &&\r\n                foundHeight < boxSize\r\n              ) {\r\n                minX = Math.min(minX, component.limites.topLeft.x);\r\n                minY = Math.min(minY, component.limites.topLeft.y);\r\n                maxX = Math.max(maxX, component.limites.bottomRight.x);\r\n                maxY = Math.max(maxY, component.limites.bottomRight.y);\r\n                pointsCount += component.puntos.length;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const foundWidth = maxX - minX;\r\n        const foundHeight = maxY - minY;\r\n        if (\r\n          pointsCount > 10 &&\r\n          foundWidth < boxSize &&\r\n          foundHeight < boxSize &&\r\n          foundWidth > boxSize / 10 &&\r\n          foundHeight > boxSize / 3\r\n        ) {\r\n          const numberImage = greyScale.subImage(\r\n            Math.max(0, minX - 2),\r\n            Math.max(0, minY - 2),\r\n            Math.min(size - 1, maxX + 2),\r\n            Math.min(size - 1, maxY + 2)\r\n          );\r\n          results.push({\r\n            x,\r\n            y,\r\n            minX,\r\n            maxX,\r\n            minY,\r\n            maxY,\r\n            numberImage,\r\n            contents: 0,\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Celdas en el video\r\n   */\r\n  getTextDetailsForBox(\r\n    x: number,\r\n    y: number,\r\n    digit: number,\r\n    isKnown: boolean,\r\n    transform: Transform\r\n  ): SolvedBox {\r\n    const boxSize = PROCESSING_SIZE / 9;\r\n    const p1 = transformPoint(\r\n      { x: (x + 0.5) * boxSize, y: y * boxSize },\r\n      transform\r\n    );\r\n    const p2 = transformPoint(\r\n      { x: (x + 0.5) * boxSize, y: (y + 1) * boxSize },\r\n      transform\r\n    );\r\n    // Centro\r\n    const textPosition = transformPoint(\r\n      { x: (x + 0.5) * boxSize, y: (y + 0.5) * boxSize },\r\n      transform\r\n    );\r\n    // Angulo de texto\r\n    const dx = p1.x - p2.x;\r\n    const dy = p1.y - p2.y;\r\n    const digitRotation = Math.atan2(dx, dy);\r\n\r\n    // Altura de texto aprox.\r\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\r\n    console.log(digit,\r\n      digitHeight,\r\n      digitRotation,isKnown,textPosition)\r\n    return {\r\n      digit,\r\n      digitHeight,\r\n      digitRotation,\r\n      conocido: isKnown,\r\n      position: textPosition,\r\n    };\r\n  }\r\n\r\n  createSolvedPuzzle(solver: SudokuSolver, transform: Transform) {\r\n    const results: SolvedBox[][] = new Array(9);\r\n    for (let y = 0; y < 9; y++) {\r\n      results[y] = new Array(9);\r\n    }\r\n    solver.solution.forEach((sol) => {\r\n      const { x, y, entry, isKnown } = sol.guess;\r\n      results[y][x] = this.getTextDetailsForBox(\r\n        x,\r\n        y,\r\n        entry,\r\n        isKnown,\r\n        transform\r\n      );\r\n    });\r\n    return results;\r\n  }\r\n\r\n  sanityCheckCorners({\r\n    topLeft,\r\n    topRight,\r\n    bottomLeft,\r\n    bottomRight,\r\n  }: {\r\n    topLeft: Punto;\r\n    topRight: Punto;\r\n    bottomLeft: Punto;\r\n    bottomRight: Punto;\r\n  }) {\r\n    function length(p1: Punto, p2: Punto) {\r\n      const dx = p1.x - p2.x;\r\n      const dy = p1.y - p2.y;\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    const topLineLength = length(topLeft, topRight);\r\n    const leftLineLength = length(topLeft, bottomLeft);\r\n    const rightLineLength = length(topRight, bottomRight);\r\n    const bottomLineLength = length(bottomLeft, bottomRight);\r\n    if (\r\n      topLineLength < 0.5 * bottomLineLength ||\r\n      topLineLength > 1.5 * bottomLineLength\r\n    )\r\n      return false;\r\n    if (\r\n      leftLineLength < 0.7 * rightLineLength ||\r\n      leftLineLength > 1.3 * rightLineLength\r\n    )\r\n      return false;\r\n    if (\r\n      leftLineLength < 0.5 * bottomLineLength ||\r\n      leftLineLength > 1.5 * bottomLineLength\r\n    )\r\n      return false;\r\n    return true;\r\n  }\r\n  \r\n  //Empieza procesado de video\r\n  async processFrame() {\r\n    if (!this.isVideoRunning) {\r\n      // No hay video \r\n      return;\r\n    }\r\n    if (this.isProcessing) {\r\n      // Se está procesando\r\n      return;\r\n    }\r\n    try {\r\n      let startTime = performance.now();\r\n      // capturar imagen\r\n      const image = this.captureImagen(this.video);\r\n\r\n      // Aplicar threshold\r\n      const thresholded = this.threshold(image.clone(), 20, 20);\r\n      // Extraer la región más grande entre los puntos\r\n      const largestConnectedComponent = getLargestConnectedComponent(\r\n        thresholded,\r\n        {\r\n          minAspectRatio: 0.5,\r\n          maxAspectRatio: 1.5,\r\n          minSize:\r\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\r\n          maxSize:\r\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9,\r\n        }\r\n      );\r\n      // Si se encuentra\r\n      if (largestConnectedComponent) {\r\n        // Calcular esquinas (Manhattan)\r\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\r\n        \r\n        if (this.sanityCheckCorners(potentialCorners)) {\r\n          this.corners = potentialCorners;\r\n          const transform = findHomographicTransform(\r\n            PROCESSING_SIZE,\r\n            this.corners\r\n          );\r\n\r\n          // Mostrar gridlines\r\n          this.gridLines = this.createGridLines(transform);\r\n\r\n          // Extraer tablero grayscale\r\n          const extractedImageGreyScale = extractSquareFromRegion(\r\n            image,\r\n            PROCESSING_SIZE,\r\n            transform\r\n          );\r\n          // Extraer tablero de imagen threshold\r\n          const extractedImageThresholded = extractSquareFromRegion(\r\n            thresholded,\r\n            PROCESSING_SIZE,\r\n            transform\r\n          );\r\n          // Extraer celdas con números\r\n          const boxes = this.extractBoxes(\r\n            extractedImageGreyScale,\r\n            extractedImageThresholded\r\n          );\r\n          // Se cumple la condición de mínimos?\r\n          if (boxes.length > MIN_BOXES) {\r\n            // Aplicar la red neuronal\r\n            await fillInPrediction(boxes);\r\n            // Dancing Links\r\n            const solver = new SudokuSolver();\r\n            boxes.forEach((box) => {\r\n              console.log(\"El dígito\", box.contents);\r\n              if (box.contents !== 0) {\r\n                solver.setNumber(box.x, box.y, box.contents - 1);\r\n              }\r\n            });\r\n            // Crear solución\r\n            if (solver.search(0)) {\r\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\r\n            } else {\r\n              this.solvedPuzzle = null;\r\n            }\r\n            this.TiempoTotal =\r\n            0.1 * (performance.now() - startTime) + this.TiempoTotal * 0.9;\r\n            console.log(\"Tiempo de resolución\", this.TiempoTotal)\r\n          }\r\n        } else {\r\n          this.corners = null;\r\n          this.gridLines = null;\r\n          this.solvedPuzzle = null;\r\n        }\r\n      } else {\r\n        this.corners = null;\r\n        this.gridLines = null;\r\n        this.solvedPuzzle = null;\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n    this.isProcessing = false;\r\n    setTimeout(() => this.processFrame(), 20);\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}